// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "RobotMap.h"
#include "LiveWindow/LiveWindow.h"

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=ALLOCATION
std::shared_ptr<SpeedController> RobotMap::hHBaseDriveHHSCLeftFront;
std::shared_ptr<SpeedController> RobotMap::hHBaseDriveHHSCLeftRear;
std::shared_ptr<SpeedController> RobotMap::hHBaseDriveHHSCRightFront;
std::shared_ptr<SpeedController> RobotMap::hHBaseDriveHHSCRightRear;
std::shared_ptr<RobotDrive> RobotMap::hHBaseDriveHHRobotDrive41;
std::shared_ptr<Encoder> RobotMap::hHBaseDriveHHEBaseDrive;
//std::shared_ptr<AnalogGyro> RobotMap::hHBaseDriveHHGBaseDrive;
std::shared_ptr<SpeedController> RobotMap::hHGearReleaseHHSCGearRelease;
std::shared_ptr<SpeedController> RobotMap::hHGearTiltHHSCGearTilt;
std::shared_ptr<SpeedController> RobotMap::hHRopeClimbHHSCRopeClimb;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=ALLOCATION
std::shared_ptr<ADXRS450_Gyro> RobotMap::hHBaseDriveHHGBaseDrive;
void RobotMap::init() {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    LiveWindow *lw = LiveWindow::GetInstance();

    hHBaseDriveHHSCLeftFront.reset(new TalonSRX(0));
    lw->AddActuator("HHBaseDrive", "HHSCLeftFront", std::static_pointer_cast<TalonSRX>(hHBaseDriveHHSCLeftFront));
    
    hHBaseDriveHHSCLeftRear.reset(new TalonSRX(1));
    lw->AddActuator("HHBaseDrive", "HHSCLeftRear", std::static_pointer_cast<TalonSRX>(hHBaseDriveHHSCLeftRear));
    
    hHBaseDriveHHSCRightFront.reset(new TalonSRX(2));
    lw->AddActuator("HHBaseDrive", "HHSCRightFront", std::static_pointer_cast<TalonSRX>(hHBaseDriveHHSCRightFront));
    
    hHBaseDriveHHSCRightRear.reset(new TalonSRX(3));
    lw->AddActuator("HHBaseDrive", "HHSCRightRear", std::static_pointer_cast<TalonSRX>(hHBaseDriveHHSCRightRear));
    
    hHBaseDriveHHRobotDrive41.reset(new RobotDrive(hHBaseDriveHHSCLeftFront, hHBaseDriveHHSCLeftRear,
              hHBaseDriveHHSCRightFront, hHBaseDriveHHSCRightRear));
    
    hHBaseDriveHHRobotDrive41->SetSafetyEnabled(false);
        hHBaseDriveHHRobotDrive41->SetExpiration(0.1);
        hHBaseDriveHHRobotDrive41->SetSensitivity(0.5);
        hHBaseDriveHHRobotDrive41->SetMaxOutput(1.0);

    hHBaseDriveHHEBaseDrive.reset(new Encoder(8, 9, false, Encoder::k4X));
    lw->AddSensor("HHBaseDrive", "HHEBaseDrive", hHBaseDriveHHEBaseDrive);
    hHBaseDriveHHEBaseDrive->SetDistancePerPulse(1.0);
    hHBaseDriveHHEBaseDrive->SetPIDSourceType(PIDSourceType::kDisplacement);
    hHBaseDriveHHGBaseDrive.reset(new ADXRS450_Gyro());
    lw->AddSensor("HHBaseDrive", "HHGBaseDrive", hHBaseDriveHHGBaseDrive);
    //hHBaseDriveHHGBaseDrive->SetSensitivity(0.007);
    hHGearReleaseHHSCGearRelease.reset(new VictorSP(6));
    lw->AddActuator("HHGearRelease", "HHSCGearRelease", std::static_pointer_cast<VictorSP>(hHGearReleaseHHSCGearRelease));
    
    hHGearTiltHHSCGearTilt.reset(new Talon(19));
    lw->AddActuator("HHGearTilt", "HHSCGearTilt", std::static_pointer_cast<Talon>(hHGearTiltHHSCGearTilt));
    
    hHRopeClimbHHSCRopeClimb.reset(new VictorSP(7));
    lw->AddActuator("HHRopeClimb", "HHSCRopeClimb", std::static_pointer_cast<VictorSP>(hHRopeClimbHHSCRopeClimb));
    


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    hHBaseDriveHHEBaseDrive->SetDistancePerPulse(0.0122);
}
